import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import re
from datetime import datetime
from streamlit_gsheets import GSheetsConnection

# --- 초기 설정 및 페이지 구성 ---
st.set_page_config(layout="wide", page_title="수입 경쟁력 진단 솔루션")

# --- Google Sheets에서 데이터 불러오기 ---
# 캐시를 사용하여 10분마다 데이터를 새로고침합니다.
@st.cache_data(ttl=600)
def load_company_data():
    """Google Sheets에서 회사 데이터를 불러옵니다."""
    try:
        # Streamlit의 Secrets에 저장된 gsheets 연결 정보를 사용합니다.
        conn = st.connection("gsheets", type=GSheetsConnection)
        df = conn.read(worksheet="Sheet1") # 'Sheet1'은 실제 시트 이름으로 변경해야 합니다.

        # 데이터 클리닝 및 타입 변환
        df.dropna(how="all", inplace=True) # 비어있는 행 제거
        df['Date'] = pd.to_datetime(df['Date'])
        df['Volume'] = pd.to_numeric(df['Volume'])
        df['Value'] = pd.to_numeric(df['Value'])
        return df
    except Exception as e:
        st.error(f"Google Sheets에서 데이터를 불러오는 중 오류가 발생했습니다: {e}")
        st.info("Streamlit Secrets 설정 및 Google Sheet 공유 설정을 확인해주세요. 자세한 내용은 가이드를 참고하세요.")
        return pd.DataFrame() # 오류 발생 시 빈 데이터프레임 반환

OUR_COMPANY_DATA = load_company_data()

# --- 스마트 매칭 로직 (하이브리드 방식) ---
def clean_text(text):
    """텍스트 정제: 소문자화, 특수문자 제거"""
    if not isinstance(text, str):
        return ''
    text = text.lower()
    text = re.sub(r'\[.*?\]', ' ', text) # [위스키] 같은 대괄호 내용 제거
    text = re.sub(r'[^a-z0-9\s]', ' ', text) # 영문, 숫자, 공백 제외 모두 제거
    return ' '.join(text.split())

def smart_match_products(user_product_name, company_product_list):
    """사용자 입력과 DB 제품명을 비교하여 매칭되는 제품 목록 반환"""
    matched_products = set()
    
    # 1. 토큰 방식 검사를 위한 준비
    user_tokens = set(clean_text(user_product_name).split())
    if not user_tokens:
        return []

    # 2. 공백 제거 방식 검사를 위한 준비
    user_no_space = re.sub(r'\s+', '', clean_text(user_product_name))

    for db_product_name in company_product_list:
        # 1차 검사 (토큰 방식)
        db_tokens = set(clean_text(db_product_name).split())
        if user_tokens.issubset(db_tokens):
            matched_products.add(db_product_name)
            continue # 매칭 성공 시 다음 제품으로

        # 2차 검사 (공백 제거 방식)
        db_no_space = re.sub(r'\s+', '', clean_text(db_product_name))
        if user_no_space in db_no_space:
            matched_products.add(db_product_name)
            
    return sorted(list(matched_products))

# --- 데이터 처리 로직 (Data Processor) ---
# (이전과 동일, 필터링된 데이터프레임을 입력받음)
def process_analysis_data(target_df, company_df, target_importer_name):
    if company_df.empty:
        return {}, {}, {}
        
    target_df['Importer'] = target_importer_name.upper()
    all_df = pd.concat([company_df, target_df], ignore_index=True)
    all_df['unitPrice'] = all_df['Value'] / all_df['Volume']
    all_df['year'] = all_df['Date'].dt.year
    all_df['monthYear'] = all_df['Date'].dt.to_period('M').astype(str)

    # (분석 로직은 이전과 동일하므로 생략)
    # 1. 경쟁사 단가 비교 분석
    competitor_analysis = {}
    for _, row in target_df.iterrows():
        year = row['Date'].year
        exporter = row['Exporter'].upper()
        
        if year not in competitor_analysis:
            competitor_analysis[year] = {}
        if exporter not in competitor_analysis[year]:
            related_trades = all_df[(all_df['year'] == year) & (all_df['Exporter'].str.upper() == exporter)]
            
            importer_prices = related_trades.groupby('Importer').apply(
                lambda x: x['Value'].sum() / x['Volume'].sum()
            ).reset_index(name='unitPrice').sort_values('unitPrice')

            top5 = importer_prices.head(5)
            is_target_in_top5 = target_importer_name.upper() in top5['Importer'].values
            
            if not is_target_in_top5:
                target_price_df = pd.DataFrame([{'Importer': target_importer_name.upper(), 'unitPrice': row['Value'] / row['Volume']}])
                top5 = pd.concat([top5, target_price_df]).sort_values('unitPrice').head(6)
            
            competitor_analysis[year][exporter] = top5

    # 2. 연도별 수입 중량 및 단가 분석
    yearly_analysis = {}
    for _, row in target_df.iterrows():
        year = row['Date'].year
        exporter = row['Exporter'].upper()
        origin = row['Origin Country'].upper()
        
        key = (year, exporter, origin)
        if key not in yearly_analysis:
            target_unit_price = row['Value'] / row['Volume']
            
            other_companies = all_df[
                (all_df['year'] == year) & 
                (all_df['Exporter'].str.upper() == exporter) & 
                (all_df['Origin Country'].str.upper() == origin) &
                (all_df['Importer'].str.upper() != target_importer_name.upper()) &
                (all_df['unitPrice'] < target_unit_price)
            ]
            
            saving_info = None
            if not other_companies.empty:
                avg_unit_price = other_companies['Value'].sum() / other_companies['Volume'].sum()
                potential_saving = (target_unit_price - avg_unit_price) * row['Volume']
                saving_info = {'potential_saving': potential_saving}

            yearly_data = all_df[(all_df['Exporter'].str.upper() == exporter) & (all_df['Origin Country'].str.upper() == origin)]
            summary = yearly_data.groupby('year').agg(
                volume=('Volume', 'sum'),
                value=('Value', 'sum')
            ).reset_index()
            summary['unitPrice'] = summary['value'] / summary['volume']
            
            yearly_analysis[key] = {'chart_data': summary, 'saving_info': saving_info}

    # 3. 시계열 단가 비교 분석
    time_series_analysis = {}
    for _, row in target_df.iterrows():
        origin = row['Origin Country'].upper()
        if origin not in time_series_analysis:
            related_trades = all_df[all_df['Origin Country'].str.upper() == origin]
            
            monthly_summary = related_trades.groupby('monthYear').agg(
                avgPrice=('unitPrice', 'mean'),
                bestPrice=('unitPrice', 'min')
            ).reset_index()

            target_trades = related_trades[related_trades['Importer'].str.upper() == target_importer_name.upper()]
            target_monthly = target_trades.groupby('monthYear').agg(
                targetPrice=('unitPrice', 'mean')
            ).reset_index()

            chart_data = pd.merge(monthly_summary, target_monthly, on='monthYear', how='left').sort_values('monthYear')
            
            target_unit_price = row['Value'] / row['Volume']
            cheaper_trades = all_df[(all_df['Origin Country'].str.upper() == origin) & (all_df['unitPrice'] < target_unit_price)]
            saving_info = None
            if not cheaper_trades.empty:
                avg_unit_price = cheaper_trades['Value'].sum() / cheaper_trades['Volume'].sum()
                potential_saving = (target_unit_price - avg_unit_price) * row['Volume']
                saving_info = {'potential_saving': potential_saving}

            time_series_analysis[origin] = {'chart_data': chart_data, 'saving_info': saving_info}
            
    return competitor_analysis, yearly_analysis, time_series_analysis


# --- UI Components ---
def login_screen():
    st.title("🔐 수입 경쟁력 진단 솔루션")
    st.write("솔루션 접속을 위해 비밀번호를 입력해주세요.")
    
    with st.form("login_form"):
        password = st.text_input("비밀번호", type="password")
        submitted = st.form_submit_button("접속하기")
        
        if submitted:
            if password == "tridgeDemo_2025":
                st.session_state['logged_in'] = True
                st.rerun()
            else:
                st.error("비밀번호가 올바르지 않습니다.")

def main_dashboard():
    st.title("📈 수입 경쟁력 진단 솔루션")
    st.markdown("귀사의 수입 데이터를 기반으로 시장 내 경쟁력을 진단하고 비용 절감 기회를 포착하세요.")

    # 데이터 로딩 실패 시 실행 중단
    if OUR_COMPANY_DATA.empty:
        return

    # --- 데이터 입력 폼 ---
    with st.expander("STEP 1: 분석 정보 입력", expanded='analysis_results' not in st.session_state):
        importer_name = st.text_input("1. 귀사의 수입업체명을 입력해주세요.", placeholder="예: 트릿지", key="importer_name").upper()
        
        st.markdown("---")
        st.markdown("2. 분석할 구매 내역을 입력해주세요. **'제품 상세명'**을 활용하여 더 정확하게 분석할 수 있습니다.")
        
        if 'rows' not in st.session_state:
            st.session_state['rows'] = [{'id': 1}]

        for i, row in enumerate(st.session_state.rows):
            cols = st.columns([2, 3, 2, 2, 2, 2, 1])
            with cols[0]:
                st.date_input("수입일", key=f"date_{i}")
            with cols[1]:
                st.text_input("제품 상세명", placeholder="예: 발렌타인 17년", key=f"product_name_{i}")
            with cols[2]:
                st.text_input("HS-CODE(6자리)", max_chars=6, key=f"hscode_{i}")
            with cols[3]:
                countries = [''] + sorted(OUR_COMPANY_DATA['Export Country'].unique())
                st.selectbox("원산지", countries, key=f"origin_{i}", index=0)
            with cols[4]:
                exporters = [''] + sorted(OUR_COMPANY_DATA['Exporter'].unique())
                st.selectbox("수출업체", exporters, key=f"exporter_{i}", index=0)
            with cols[5]:
                st.number_input("수입 중량(KG)", min_value=0.01, format="%.2f", key=f"volume_{i}")
            with cols[6]:
                if len(st.session_state.rows) > 1:
                    if st.button("삭제", key=f"delete_{i}"):
                        st.session_state.rows.pop(i)
                        st.rerun()

        if st.button("➕ 내역 추가하기"):
            st.session_state.rows.append({'id': len(st.session_state.rows) + 1})
            st.rerun()

        st.markdown("---")
        consent = st.checkbox("입력하신 정보는 데이터 분석 품질 향상을 위해 저장 및 활용되는 것에 동의합니다.")
        
        analyze_button = st.button("분석하기", type="primary")

    # --- 분석 로직 실행 및 필터 표시 ---
    if analyze_button:
        if not importer_name:
            st.warning("수입업체명을 입력해주세요.")
        elif not consent:
            st.warning("데이터 활용 동의에 체크해주세요.")
        else:
            with st.spinner('데이터를 분석 중입니다...'):
                # 입력된 데이터 수집
                purchase_data = []
                all_matched_products = set()
                company_product_list = OUR_COMPANY_DATA['Reported Product Name'].unique()

                for i in range(len(st.session_state.rows)):
                    user_product_name = st.session_state[f'product_name_{i}']
                    if not user_product_name:
                        st.error(f"{i+1}번째 행의 '제품 상세명'을 입력해주세요.")
                        return

                    # 스마트 매칭 실행
                    matched = smart_match_products(user_product_name, company_product_list)
                    all_matched_products.update(matched)
                    
                    entry = {
                        'Date': st.session_state[f'date_{i}'],
                        'Reported Product Name': user_product_name,
                        'HS-CODE': st.session_state[f'hscode_{i}'],
                        'Origin Country': st.session_state[f'origin_{i}'].upper(),
                        'Export Country': st.session_state[f'origin_{i}'].upper(),
                        'Exporter': st.session_state[f'exporter_{i}'].upper(),
                        'Volume': st.session_state[f'volume_{i}'],
                        'Value': 0, # Value는 입력받지 않으므로 임시값 처리
                    }
                    purchase_data.append(entry)
                
                st.session_state['user_input_df'] = pd.DataFrame(purchase_data)
                st.session_state['matched_products'] = sorted(list(all_matched_products))
                st.session_state['selected_products'] = st.session_state['matched_products']
                st.session_state['importer_name_result'] = importer_name
                st.session_state['analysis_results'] = True # 분석 결과 표시 트리거

    # --- 분석 결과 표시 ---
    if 'analysis_results' in st.session_state:
        st.header("📊 분석 결과")
        
        # --- 필터 기능 ---
        with st.expander("STEP 2: 분석 대상 제품 필터링", expanded=True):
            st.info("스마트 매칭을 통해 아래 제품들이 분석 대상으로 선택되었습니다. 원치 않는 제품은 체크 해제하여 제외할 수 있습니다.")
            
            selected = st.multiselect(
                "분석에 활용할 제품명을 선택하세요.",
                options=st.session_state['matched_products'],
                default=st.session_state['selected_products'],
                key="product_filter"
            )
            st.session_state['selected_products'] = selected

        if not st.session_state['selected_products']:
            st.warning("분석할 제품을 하나 이상 선택해주세요.")
        else:
            # 선택된 제품 기준으로 데이터 필터링
            filtered_company_df = OUR_COMPANY_DATA[OUR_COMPANY_DATA['Reported Product Name'].isin(st.session_state['selected_products'])]
            
            # 분석 실행
            target_df = st.session_state['user_input_df']
            # 사용자가 입력한 제품과 매칭된 제품들만 분석 대상으로 한정
            target_df_filtered = target_df[target_df['Reported Product Name'].apply(lambda x: bool(smart_match_products(x, st.session_state['selected_products'])))]

            if target_df_filtered.empty:
                st.warning("선택된 제품과 매칭되는 사용자 입력이 없습니다.")
            else:
                competitor_res, yearly_res, timeseries_res = process_analysis_data(target_df_filtered, filtered_company_df, st.session_state['importer_name_result'])

                # (차트 표시 로직은 이전과 동일하므로 생략)
                # 1. 경쟁사 단가 비교
                st.subheader("1. 경쟁사 Unit Price 비교 분석")
                if not competitor_res: st.write("비교할 경쟁사 데이터가 없습니다.")
                for year, exporters in competitor_res.items():
                    for exporter, data in exporters.items():
                        with st.container(border=True):
                            st.markdown(f"**{year}년 / 수출업체: {exporter}**")
                            data['color'] = np.where(data['Importer'] == st.session_state['importer_name_result'], 'red', 'blue')
                            fig = px.bar(data, x='Importer', y='unitPrice', title=f"{year}년 {exporter} 수입사별 Unit Price",
                                         labels={'Importer': '수입사', 'unitPrice': 'Unit Price (USD/KG)'},
                                         color='color', color_discrete_map={'red':'#ef4444', 'blue':'#3b82f6'})
                            fig.update_layout(showlegend=False)
                            st.plotly_chart(fig, use_container_width=True)
                
                # (이하 차트 표시 로직 동일)


        if st.button("🔄 새로운 분석 시작하기"):
            # 세션 상태 초기화
            keys_to_keep = ['logged_in']
            for key in list(st.session_state.keys()):
                if key not in keys_to_keep:
                    del st.session_state[key]
            st.rerun()


# --- 메인 로직 ---
if 'logged_in' not in st.session_state:
    st.session_state['logged_in'] = False

if st.session_state['logged_in']:
    main_dashboard()
else:
    login_screen()
